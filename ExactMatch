// =========================================================
// ExactMatch — Version Corrigée (Serveur Central)
// Protocole PSI via Catalano-Fiore (Forme Seconde)
// =========================================================

use num_bigint::BigUint;
use num_bigint::RandBigInt;
use rand_core::OsRng;
use std::time::Instant;
use std::collections::{HashMap, HashSet};

use crate::fiore_catalano::cf_encrypt::cf_encrypt::cf_encrypt;
use crate::fiore_catalano::cf_mul::cf_mul::cf_mul;
use crate::fiore_catalano::cf_mul_dec::cf_mul_dec::cf_mul_dec;
use crate::fiore_catalano::cf_add::cf_add::cf_add;
use crate::fiore_catalano::cf_add::cf_add_dec::cf_add_dec;
use crate::paillier::p_keygen::p_keygen::p_keygen;
use crate::paillier::p_encrypt::p_encrypt::p_encrypt;
use crate::paillier::p_keygen::p_keygen::KeyPair;

// ─────────────────────────────────────────────────────────
// [C1] Constantes — HASH_BITS
// ─────────────────────────────────────────────────────────

/// Nombre de bits de la fonction de hachage.
/// h : {0,1}* → {0,1}^30, TABLE_SIZE = 2^30.
/// Avec n = 30 000 NSS et TABLE_SIZE = 2^30 ≈ 1 milliard,
/// la probabilité de collision est négligeable (~2.8×10⁻⁵).
pub const HASH_BITS: usize = 30;
pub const TABLE_SIZE: usize = 1 << HASH_BITS;  // 2^30 = 1 073 741 824

// ─────────────────────────────────────────────────────────
// Types publics
// ─────────────────────────────────────────────────────────

/// Chiffré CF Première Forme : (c0, c1)
/// c0 = [m - b]_N  (en clair),  c1 = P.Enc(b)
pub type CfFst = (BigUint, BigUint);

/// Chiffré CF Seconde Forme : (c0'', c1'', c2'')
/// Produit par CF.Mul — déchiffrement via CF.Dec
pub type CfSnd = (BigUint, BigUint, BigUint);

/// Table creuse : seules les positions actives (t[i]=1) sont stockées.
/// Toute position absente vaut implicitement 0.
pub struct SparseTable {
    pub active: HashSet<usize>,
}

impl SparseTable {
    /// Construit la table à partir d'une liste de NSS.
    /// t[simple_hash(nss)] = 1 pour chaque nss de la base.
    pub fn build(nss_list: &[String]) -> Self {
        let mut active = HashSet::new();
        for nss in nss_list {
            active.insert(simple_hash(nss));
        }
        SparseTable { active }
    }

    pub fn contains(&self, pos: usize) -> bool {
        self.active.contains(&pos)
    }

    pub fn len(&self) -> usize {
        self.active.len()
    }
    /// Retourne les positions communes entre `self` et `other`.
    /// Itère sur l'ensemble le plus petit pour être plus efficace.
    pub fn common_positions(&self, other: &SparseTable) -> Vec<usize> {
        let (small, big) = if self.active.len() <= other.active.len() {
            (&self.active, &other.active)
        } else {
            (&other.active, &self.active)
        };
        let mut res = Vec::with_capacity(small.len());
        for &pos in small.iter() {
            if big.contains(&pos) {
                res.push(pos);
            }
        }
        res
    }
}

/// les masques sont générés pour toutes les positions actives
/// et échangés de façon croisée avant tout calcul homomorphe.
pub struct MaskBundle {
    pub masks_clear: HashMap<usize, BigUint>,  // bi en clair (secret)
    pub masks_enc:   HashMap<usize, BigUint>,  // P.Enc_pk(bi) (public)
}

// ─────────────────────────────────────────────────────────
// Fonction de hachage — PDF 
// h : {0,1}* → {0,1}^HASH_BITS  (JS-like 32-bit tronqué)
// ─────────────────────────────────────────────────────────

pub fn simple_hash(s: &str) -> usize {
    let mut h: u32 = 0;
    for ch in s.chars() {
        h = h.wrapping_shl(7).wrapping_sub(h).wrapping_add(ch as u32);
    }
    (h as usize) & (TABLE_SIZE - 1)
}

// ─────────────────────────────────────────────────────────
// Chargement du CSV — colonne NSS uniquement
// ─────────────────────────────────────────────────────────

/// Lit un fichier CSV et retourne Vec<String> des valeurs NSS.
pub fn load_nss_from_csv(path: &str) -> Vec<String> {
    use std::fs::File;
    use std::io::{BufRead, BufReader};

    let file = File::open(path)
        .unwrap_or_else(|e| panic!("Impossible d'ouvrir {} : {}", path, e));
    let reader = BufReader::new(file);
    let mut lines = reader.lines();

    let header = lines.next().expect("Fichier vide").expect("Erreur lecture");
    let cols: Vec<&str> = header.split(',').collect();
    let nss_col = cols.iter().position(|c| c.trim() == "NSS")
        .expect("Colonne 'NSS' introuvable");

    lines
        .filter_map(|line| {
            let line = line.ok()?;
            let val = line.split(',').nth(nss_col)?.trim().to_string();
            if val.is_empty() { None } else { Some(val) }
        })
        .collect()
}

// ─────────────────────────────────────────────────────────
// Phase 0 — Génération des clés
// ─────────────────────────────────────────────────────────

pub fn phase0_keygen(label: &str, bits: u64) -> KeyPair {
    println!("  [Phase 0] {} : génération des clés ({} bits)...", label, bits);
    let t = Instant::now();
    let kp = p_keygen(bits);
    println!("  [Phase 0] {} : clés générées en {:.3?}", label, t.elapsed());
    kp.expect("Error")
}

// ─────────────────────────────────────────────────────────
// Phase 1 — Construction des tables de bits creuses
// ─────────────────────────────────────────────────────────

pub fn phase1_build_table(label: &str, nss_list: &[String]) -> SparseTable {
    println!(
        "  [Phase 1] {} : construction de la table creuse ({} NSS, TABLE_SIZE=2^{})...",
        label, nss_list.len(), HASH_BITS
    );
    let table = SparseTable::build(nss_list);
    println!(
        "  [Phase 1] {} : {} position(s) active(s) — t[i]=1.",
        label, table.len()
    );
    table
}

// ─────────────────────────────────────────────────────────
// Phase 2 — Échange croisé des masques chiffrés
// ─────────────────────────────────────────────────────────

pub fn phase2_generate_masks(label: &str, table: &SparseTable, kp: &KeyPair) -> MaskBundle {
    println!(
        "  [Phase 2] {} : génération + chiffrement de {} masques sous pk_{}...",
        label, table.len(), label
    );
    let mut rng = OsRng;
    let mut masks_clear = HashMap::with_capacity(table.len());
    let mut masks_enc   = HashMap::with_capacity(table.len());

    for &pos in &table.active {
        let b_i = rng.gen_biguint_below(&kp.public_key.n);
        // [C2] On stocke le chiffré sous la clé de CETTE BD (pas du serveur)
        let enc_b_i = p_encrypt(&b_i, &kp.public_key)
            .expect("Chiffrement masque Phase 2 échoué");
        masks_clear.insert(pos, b_i);
        masks_enc.insert(pos, enc_b_i);
    }

    println!(
        "  [Phase 2] {} : {} masques prêts -> masks_enc transmis au Serveur et à l'autre BD.",
        label, masks_clear.len()
    );
    MaskBundle { masks_clear, masks_enc }
}

// ─────────────────────────────────────────────────────────
// Phase 3 — Calcul homomorphe + agrégation
// ─────────────────────────────────────────────────────────

pub fn phase3_server_compute(
    table1:  &SparseTable,
    table2:  &SparseTable,
    bundle1: &MaskBundle,    // masques de BD1 (bi)
    bundle2: &MaskBundle,    // masques de BD2 (b'i)
    kp1:     &KeyPair,
    kp2:     &KeyPair,
) -> (CfFst, CfFst) {       // un seul agrégat par BD (Forme Première)

    println!("  [Phase 3] Serveur : calcul homomorphe CF...");
    let t_start = Instant::now();

    // Positions communes : t[i]=1 ET t'[i]=1
    let common: Vec<usize> = table1.common_positions(table2);

    println!(
        "  [Phase 3] Serveur : {} position(s) commune(s) (t[i]=1 ^ t'[i]=1).",
        common.len()
    );

    // Valeur neutre pour CF.Add : CF.Enc(0) = (0, P.Enc(0)) = (0, 1) sous Paillier
    // un accumulateur à 0 en Forme Première = (0, 1_paillier).
    let mut agg_bd1: Option<CfFst> = None;
    let mut agg_bd2: Option<CfFst> = None;

    let one = BigUint::from(1u32);

    for pos in &common {
        // Récupérer bi et b'i depuis les MaskBundles reçus de BD1/BD2 ──
        let bi = bundle1.masks_clear.get(pos)
            .expect("Position active dans table1 mais bi absent du bundle1");
        let bi_p = bundle2.masks_clear.get(pos)
            .expect("Position active dans table2 mais b'i absent du bundle2");

        // Construire CF.Encrypt pour les deux masques sous CHAQUE PK

        let ft1  = cf_encrypt(&one, bi,   &kp1.public_key)
            .expect("CF.Enc BD1 Phase 3 échoué");
        let ft1_p = cf_encrypt(&one, bi_p, &kp1.public_key)
            .expect("CF.Enc BD1 (masque BD2 sous pk1) Phase 3 échoué");

        let ft2  = cf_encrypt(&one, bi,   &kp2.public_key)
            .expect("CF.Enc BD2 Phase 3 échoué");
        let ft2_p = cf_encrypt(&one, bi_p, &kp2.public_key)
            .expect("CF.Enc BD2 (masque BD1 sous pk2) Phase 3 échoué");

        // Multiplication sous pk1 et pk2 séparément → deux Formes Seconde
        let sf1 = cf_mul(&ft1,  &ft1_p, &kp1.public_key)
            .expect("CF.Mul BD1 Phase 3 échoué");
        let sf2 = cf_mul(&ft2,  &ft2_p, &kp2.public_key)
            .expect("CF.Mul BD2 Phase 3 échoué");

        // DEBUG: déchiffrer localement les Formes Seconde pour inspection
        // (utile pour tester ; en production le serveur ne a pas les SK).
        if common.len() <= 10 {
            let dec1 = cf_mul_dec(&sf1, &kp1.public_key, &kp1.secret_key)
                .expect("cf_mul_dec BD1 échoué");
            let dec2 = cf_mul_dec(&sf2, &kp2.public_key, &kp2.secret_key)
                .expect("cf_mul_dec BD2 échoué");
            println!("    [DEBUG !] pos={} bi={} b'i={} -> dec_sf1={} dec_sf2={}",
                pos, bi, bi_p, dec1, dec2);
        }

        

        //   (ou Enc(b'i) par bi) car Enc(m)^k = Enc(k*m).
        let fst1_c0 = sf1.0.clone(); // Enc( t*t' - bi*b'i ) sous pk1
        let fst1_c1 = sf1.1.modpow(bi_p, &kp1.public_key.n_squared); // Enc(bi*b'i) sous pk1

        let fst2_c0 = sf2.0.clone(); // Enc( t*t' - bi*b'i ) sous pk2
        let fst2_c1 = sf2.2.modpow(bi, &kp2.public_key.n_squared); // Enc(bi*b'i) sous pk2

        let fst1: CfFst = (fst1_c0, fst1_c1);
        let fst2: CfFst = (fst2_c0, fst2_c1);

        // [C4] Agrégation homomorphe CF.Add — accumulation position par position
        agg_bd1 = Some(match agg_bd1 {
            None      => fst1,
            Some(acc) => cf_add(&acc, &fst1, &kp1.public_key.n, &kp1.public_key.n_squared),
        });
        agg_bd2 = Some(match agg_bd2 {
            None      => fst2,
            Some(acc) => cf_add(&acc, &fst2, &kp2.public_key.n, &kp2.public_key.n_squared),
        });
    }

    println!(
        "  [Phase 3] Serveur : terminé en {:.3?} ({} CF.Mul + agrégation).",
        t_start.elapsed(), common.len()
    );

    // Si aucune position commune, retourner le chiffré de 0
    // CF.Enc(0) en Forme Première = (0, P.Enc(0))
    // P.Enc(0) avec g = n+1 : g^0 * r^n = r^n — on utilise r=1 → 1^n = 1
    let zero = BigUint::from(0u32);
    let enc_zero_1 = p_encrypt(&zero, &kp1.public_key)
        .expect("Chiffrement zéro BD1 échoué");
    let enc_zero_2 = p_encrypt(&zero, &kp2.public_key)
        .expect("Chiffrement zéro BD2 échoué");

    let agg1 = agg_bd1.unwrap_or((zero.clone(), enc_zero_1));
    let agg2 = agg_bd2.unwrap_or((zero,          enc_zero_2));

    (agg1, agg2)
}

// ─────────────────────────────────────────────────────────
// Phase 4 — Déchiffrement Forme Première + comptage (PDF Algo 3)
//      pi = Σ t[i]*t'[i] = |BD1 ^ BD2|
// ─────────────────────────────────────────────────────────

pub fn phase4_decrypt_and_count(
    label:    &str,
    agg:      &CfFst,   
    kp:       &KeyPair,
) -> usize {
    println!(
        "  [Phase 4] {} : déchiffrement CF Forme Première (chiffré agrégé unique)...",
        label
    );
    let t_start = Instant::now();

    // pi = Σ t[i]*t'[i] = |BD1 ^ BD2|
    let cardinal = cf_add_dec(agg, &kp.public_key, &kp.secret_key)
        .expect("cf_add_dec Phase 4 échoué");

    // Conversion BigUint → usize pour le comptage
    let count = cardinal.to_u64_digits()
        .last()
        .copied()
        .unwrap_or(0) as usize;

    println!(
        "  [Phase 4] {} : terminé en {:.3?} -> cardinal déchiffré = {}",
        label, t_start.elapsed(), count
    );
    count
}
